<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KINETIK ULTIMATE (IK & GAIN CONTROL)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Teko:wght@300;600&display=swap" rel="stylesheet">

    <style>
        body { background: #050505; margin: 0; overflow: hidden; font-family: 'Teko', sans-serif; user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UI GLASS */
        .glass-panel {
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
        }
        
        /* SLIDER CUSTOM */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%;
            background: #00F0FF; border: 2px solid #FFF; cursor: pointer; margin-top: -8px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #333; border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        /* --- CONFIG --- */
        const CFG = {
            ARM_LENGTH_UPPER: 35, // Longueur Humérus
            ARM_LENGTH_LOWER: 30, // Longueur Avant-bras
            SMOOTH: 0.15,
            STATE_LOCK: 45
        };

        const SKINS = [
            { main: '#FF0055', pants: '#E0E0E0', shoes: '#FFF' }, 
            { main: '#00F0FF', pants: '#111', shoes: '#CCC' }, 
            { main: '#CCFF00', pants: '#222', shoes: '#FF0' }, 
            { main: '#FF5500', pants: '#FFF', shoes: '#111' }  
        ];

        const App = () => {
            const [mode, setMode] = useState('INIT');
            const [gainVal, setGainVal] = useState(3.0); // Sensibilité par défaut (x3)
            const [debugVol, setDebugVol] = useState(0); // Affichage volume
            
            const canvasRef = useRef(null);
            const audioRef = useRef(null);
            const reqRef = useRef(null);
            
            // --- ENGINE STATE ---
            const engine = useRef({
                units: [],
                particles: [],
                beatTime: 0,
                realTime: 0,
                kickLevel: 0,
                isDancing: false,
                simBeat: 0
            });

            // --- 1. SYSTÈME AUDIO AVEC GAIN DYNAMIQUE ---
            const startSystem = async (useMic) => {
                if (mode !== 'INIT') return;
                
                if (useMic) {
                    try {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        const ctx = new AudioContext();
                        if (ctx.state === 'suspended') await ctx.resume();

                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        const src = ctx.createMediaStreamSource(stream);
                        
                        // NOEUD DE GAIN (Amplificateur)
                        const gainNode = ctx.createGain();
                        gainNode.gain.value = gainVal; // Valeur initiale
                        src.connect(gainNode);

                        const analyser = ctx.createAnalyser();
                        analyser.fftSize = 512;
                        analyser.smoothingTimeConstant = 0.4;
                        gainNode.connect(analyser);

                        audioRef.current = { ctx, analyser, gainNode, data: new Uint8Array(analyser.frequencyBinCount) };
                        setMode('AUDIO');
                        launchLoop();
                    } catch (e) {
                        console.error(e);
                        alert("Microphone inaccessible. Passage en mode DÉMO.");
                        setMode('DEMO');
                        launchLoop();
                    }
                } else {
                    setMode('DEMO');
                    launchLoop();
                }
            };

            const launchLoop = () => {
                addDancer(true);
                if (reqRef.current) cancelAnimationFrame(reqRef.current);
                loop();
            };

            // Changement de gain en temps réel
            const updateGain = (val) => {
                setGainVal(val);
                if (audioRef.current && audioRef.current.gainNode) {
                    audioRef.current.gainNode.gain.value = val;
                }
            };

            // --- 2. GESTION UNITÉS ---
            const addDancer = (isLeader = false) => {
                const id = Date.now() + Math.random();
                const skin = SKINS[engine.current.units.length % SKINS.length];
                const u = {
                    id,
                    z: isLeader ? 0.8 : 0.4 + Math.random() * 0.5,
                    x: isLeader ? 0.5 : -0.2,
                    tx: isLeader ? 0.5 : Math.random() * 0.8 + 0.1,
                    tz: 0, skin,
                    state: isLeader ? 'DANCE' : 'ENTER', 
                    targetId: null, animPhase: Math.random() * 100,
                    dir: 1, checkTimer: 0, lockTimer: 0, currentIntensity: 0
                };
                u.tz = u.z;
                if (!isLeader && engine.current.units.length > 0) {
                    const buddy = engine.current.units.find(b => b.state === 'DANCE' && b.lockTimer <= 0);
                    if (buddy) {
                        u.targetId = buddy.id; u.state = 'SEEK'; u.lockTimer = CFG.STATE_LOCK;
                        buddy.state = 'WAIT'; buddy.targetId = u.id; buddy.dir = -1; buddy.lockTimer = CFG.STATE_LOCK;
                    }
                }
                engine.current.units.push(u);
            };

            // --- 3. PHYSICS & IK SOLVER ---
            const updatePhysics = () => {
                engine.current.realTime++;
                let kick = 0, high = 0;

                if (mode === 'AUDIO' && audioRef.current) {
                    const { analyser, data } = audioRef.current;
                    analyser.getByteFrequencyData(data);
                    
                    // Calcul volume moyen (0-100) pour UI
                    let sum = 0; for(let i=0; i<data.length; i++) sum+=data[i];
                    const avg = sum / data.length;
                    
                    // Basses
                    let b = 0; for(let i=0; i<8; i++) b += data[i];
                    kick = (b / 8) / 255;
                    // Aigus
                    let h = 0; for(let i=100; i<120; i++) h += data[i];
                    high = (h / 20) / 255;

                    return { kick, high, vol: avg };
                } 
                else if (mode === 'DEMO') {
                    engine.current.simBeat += 0.05;
                    kick = (Math.sin(engine.current.simBeat) > 0.8) ? 0.8 : 0.05;
                    high = (Math.sin(engine.current.simBeat * 2) > 0.9) ? 0.5 : 0;
                    return { kick, high, vol: 50 };
                }
                return { kick: 0, high: 0, vol: 0 };
            };

            // --- 4. RENDER LOOP ---
            const loop = () => {
                if (!canvasRef.current) return;
                
                try {
                    const audioData = updatePhysics();
                    
                    // UI Update (Throttled)
                    if (engine.current.realTime % 4 === 0) setDebugVol(audioData.vol);

                    // Seuil Dance
                    const THRESHOLD = 0.05; // 5% de signal suffit avec le gain
                    if (audioData.kick > THRESHOLD) engine.current.isDancing = true;
                    else if (audioData.kick < 0.02) engine.current.isDancing = false;

                    // Smooth Kick Level
                    const targetK = engine.current.isDancing ? Math.max(0.5, audioData.kick) : 0;
                    engine.current.kickLevel += (targetK - engine.current.kickLevel) * CFG.SMOOTH;

                    if (engine.current.kickLevel > 0.01) engine.current.beatTime += engine.current.kickLevel * 0.3;

                    // Units Update
                    engine.current.units.forEach(u => {
                        if (u.lockTimer > 0) u.lockTimer--;
                        const desiredI = (u.state === 'DANCE' && engine.current.isDancing) ? 1 : 0;
                        u.currentIntensity += (desiredI - u.currentIntensity) * 0.15;

                        // Movement Logic (Simplified)
                        if (u.state === 'ENTER' || u.state === 'SEEK' || u.state === 'GOTO_DANCE') {
                            let tx = u.tx, tz = u.tz;
                            if (u.state === 'SEEK') {
                                const buddy = engine.current.units.find(b => b.id === u.targetId);
                                if (buddy) { tx = buddy.x - 0.14; tz = buddy.z; } else u.state = 'GOTO_DANCE';
                            }
                            const dx = tx - u.x, dz = tz - u.z;
                            if (Math.sqrt(dx*dx + dz*dz) < 0.04) {
                                if (u.state === 'SEEK') { u.state = 'CHECK'; u.checkTimer = 0; }
                                else { u.state = 'DANCE'; u.lockTimer = CFG.STATE_LOCK; }
                            } else { u.x += dx*0.06; u.z += dz*0.06; u.dir = dx>0?1:-1; }
                        } else if (u.state === 'CHECK') {
                            u.checkTimer++;
                            if (u.checkTimer === 20) engine.current.particles.push({x: u.x+0.07, z: u.z, y:-0.2, life:1});
                            if (u.checkTimer > 45) { u.state = 'GOTO_DANCE'; u.tx=Math.random()*0.8+0.1; u.tz=Math.random()*0.4+0.5; }
                        }
                    });

                    // DRAW
                    const ctx = canvasRef.current.getContext('2d', { alpha: false });
                    const W = canvasRef.current.width, H = canvasRef.current.height;
                    
                    const bgV = Math.floor(engine.current.kickLevel * 40);
                    ctx.fillStyle = `rgb(${bgV}, ${bgV/2}, ${bgV*1.5})`; 
                    ctx.fillRect(0, 0, W, H);

                    drawFloor(ctx, W, H, engine.current.kickLevel);
                    drawLasers(ctx, W, H, audioData.high);
                    [...engine.current.units].sort((a,b)=>a.z-b.z).forEach(u => drawDancer(ctx, u, W, H));
                    drawParticles(ctx, W, H);

                } catch(e) {}
                reqRef.current = requestAnimationFrame(loop);
            };

            // --- 5. IK SOLVER (Bras Solides) ---
            const solveIK = (p1, p2, len1, len2, bendDir) => {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const d = Math.sqrt(dx*dx + dy*dy);
                
                // Clamp distance (Bras ne s'étire pas)
                if (d >= len1 + len2) {
                    const ratio = (len1 + len2) / d;
                    return { x: p1.x + dx * (len1/(len1+len2)), y: p1.y + dy * (len1/(len1+len2)) }; 
                }
                
                // Law of cosines for elbow angle
                const a = Math.acos((len1*len1 + d*d - len2*len2) / (2*len1*d));
                const baseAngle = Math.atan2(dy, dx);
                const elbowAngle = baseAngle + (bendDir * a); // bendDir: 1 or -1
                
                return {
                    x: p1.x + Math.cos(elbowAngle) * len1,
                    y: p1.y + Math.sin(elbowAngle) * len1
                };
            };

            const drawDancer = (ctx, u, W, H) => {
                const scale = (0.5 + u.z * 0.75) * (H / 950);
                const sx = u.x * W, sy = (H * 0.45) + (u.z * H * 0.55);
                ctx.save(); ctx.translate(sx, sy); ctx.scale(scale, scale);

                const t = engine.current.beatTime + u.animPhase;
                const i = u.currentIntensity; 
                let bodyY = -145; // Hauteur Bassin

                // --- SQUELETTE BASE ---
                let lHip={x:-15,y:55}, rHip={x:15,y:55};
                let lSh={x:-22,y:5}, rSh={x:22,y:5}; // Épaules
                
                // MARCHE
                const wc = Math.sin(engine.current.realTime * 0.15) * 20;
                const isWalking = (u.state !== 'DANCE' && u.state !== 'CHECK' && u.state !== 'WAIT');
                
                let lFoot={x:-20+wc, y:160-Math.abs(wc)*0.2}, rFoot={x:20-wc, y:160-Math.abs(wc)*0.2};
                let lKnee={x:-18, y:105}, rKnee={x:18, y:105};
                let lHandTarget={x:-30-wc, y:70}, rHandTarget={x:30+wc, y:70};

                if (isWalking) bodyY += Math.abs(wc)*0.4;

                // SHUFFLE
                if (i > 0.01) {
                    const ph = Math.sin(t * 15);
                    const bn = Math.sin(t * 30) * 10;
                    bodyY += bn * i;
                    
                    if (ph > 0) {
                        lKnee.y = 105*(1-i) + 65*i; lKnee.x = -18*(1-i) - 20*i;
                        lFoot.y = 160*(1-i) + 100*i; lFoot.x = -20*(1-i) - 15*i;
                        rFoot.x = 20*(1-i) + 50*i; rKnee.x = 18*(1-i) + 35*i;
                    } else {
                        rKnee.y = 105*(1-i) + 65*i; rKnee.x = 18*(1-i) + 20*i;
                        rFoot.y = 160*(1-i) + 100*i; rFoot.x = 20*(1-i) + 15*i;
                        lFoot.x = -20*(1-i) - 50*i; lKnee.x = -18*(1-i) - 35*i;
                    }
                    
                    const pump = Math.sin(t * 15) * 40 * i;
                    lHandTarget.y = 70*(1-i) + (-30 + pump)*i;
                    rHandTarget.y = 70*(1-i) + (-30 - pump)*i;
                }

                // CHECK (Target Logic)
                if (u.state === 'CHECK' || u.state === 'WAIT') {
                    const lift = (u.state==='CHECK' && u.checkTimer < 20) ? u.checkTimer/20 : 1;
                    if (u.dir > 0) { rHandTarget = {x:40, y:-60}; } 
                    else { lHandTarget = {x:-40, y:-60}; }
                    
                    // Interpolation de la main vers la cible
                    if (u.dir > 0) {
                         rHandTarget.x = 30*(1-lift) + 40*lift;
                         rHandTarget.y = 70*(1-lift) - 60*lift;
                    } else {
                         lHandTarget.x = -30*(1-lift) - 40*lift;
                         lHandTarget.y = 70*(1-lift) - 60*lift;
                    }
                }

                // SOLVE IK ARMS (Calcul du coude)
                // Épaules sont relatives à BodyY
                const lShReal = {x: lSh.x, y: bodyY + lSh.y};
                const rShReal = {x: rSh.x, y: bodyY + rSh.y};
                
                // Cibles Mains relatives à BodyY (pour mouvement naturel)
                const lHandReal = {x: lHandTarget.x, y: bodyY + lHandTarget.y};
                const rHandReal = {x: rHandTarget.x, y: bodyY + rHandTarget.y};

                const lElbowReal = solveIK(lShReal, lHandReal, CFG.ARM_LENGTH_UPPER, CFG.ARM_LENGTH_LOWER, -1);
                const rElbowReal = solveIK(rShReal, rHandReal, CFG.ARM_LENGTH_UPPER, CFG.ARM_LENGTH_LOWER, 1);

                // DRAW
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.ellipse(0, 0, 35, 8, 0, 0, Math.PI*2); ctx.fill();
                
                // Segments
                const line = (x1, y1, x2, y2, w, c) => { ctx.strokeStyle=c; ctx.lineWidth=w; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); };
                const dot = (x, y, r, c='#111') => { ctx.fillStyle=c; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); };

                // JAMBES
                line(lHip.x, bodyY+lHip.y, lKnee.x, bodyY+lKnee.y, 18, u.skin.pants);
                dot(lKnee.x, bodyY+lKnee.y, 8);
                line(lKnee.x, bodyY+lKnee.y, lFoot.x, bodyY+lFoot.y, 20, u.skin.pants);
                ctx.fillStyle='#FFF'; ctx.beginPath(); ctx.ellipse(lFoot.x, bodyY+lFoot.y+5, 12, 6, 0, 0, Math.PI*2); ctx.fill();
                
                line(rHip.x, bodyY+rHip.y, rKnee.x, bodyY+rKnee.y, 18, u.skin.pants);
                dot(rKnee.x, bodyY+rKnee.y, 8);
                line(rKnee.x, bodyY+rKnee.y, rFoot.x, bodyY+rFoot.y, 20, u.skin.pants);
                ctx.fillStyle='#FFF'; ctx.beginPath(); ctx.ellipse(rFoot.x, bodyY+rFoot.y+5, 12, 6, 0, 0, Math.PI*2); ctx.fill();

                // TORSE
                ctx.fillStyle=u.skin.main; ctx.beginPath(); ctx.moveTo(-20, bodyY); ctx.lineTo(20, bodyY); ctx.lineTo(16, bodyY+55); ctx.lineTo(-16, bodyY+55); ctx.fill();

                // BRAS (IK)
                // Note: Coordonnées IK sont absolues par rapport au centre du perso, pas besoin d'ajouter bodyY
                line(lSh.x, bodyY+lSh.y, lElbowReal.x, lElbowReal.y, 12, '#E0AC69');
                dot(lElbowReal.x, lElbowReal.y, 5, '#C09050');
                line(lElbowReal.x, lElbowReal.y, lHandReal.x, lHandReal.y, 10, '#E0AC69');
                dot(lHandReal.x, lHandReal.y, 7, '#E0AC69');

                line(rSh.x, bodyY+rSh.y, rElbowReal.x, rElbowReal.y, 12, '#E0AC69');
                dot(rElbowReal.x, rElbowReal.y, 5, '#C09050');
                line(rElbowReal.x, rElbowReal.y, rHandReal.x, rHandReal.y, 10, '#E0AC69');
                dot(rHandReal.x, rHandReal.y, 7, '#E0AC69');

                // TÊTE
                ctx.fillStyle='#E0AC69'; ctx.beginPath(); ctx.arc(0, bodyY-20, 18, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle='#000'; ctx.fillRect(-12, bodyY-24, 24, 6);

                ctx.restore();
            };

            const drawFloor = (ctx, W, H, level) => {
                const hY = H * 0.45; ctx.strokeStyle = `rgba(0, 243, 255, ${0.15 + level * 0.4})`; ctx.lineWidth = 2; ctx.beginPath();
                for(let i=-6; i<=6; i++) { ctx.moveTo(W/2 + i*W*0.6, H); ctx.lineTo(W/2 + i*10, hY); }
                const scroll = (Date.now() / 20) % 50;
                for(let y=hY; y<H; y+=50) { let dy = y + scroll; if(dy>H) dy-=(H-hY); ctx.moveTo(0, dy); ctx.lineTo(W, dy); }
                ctx.stroke();
            };

            const drawLasers = (ctx, W, H, high) => {
                if (high < 0.1 && mode !== 'DEMO') return;
                const intensity = (mode === 'DEMO') ? 0.4 : high;
                ctx.globalCompositeOperation = 'lighter';
                for(let i=0; i<5; i++) {
                    ctx.strokeStyle = `hsla(${Date.now()/5 % 360}, 100%, 50%, ${intensity})`; ctx.lineWidth = 3 + intensity*15;
                    ctx.beginPath(); ctx.moveTo(W/2, -50); ctx.lineTo(W/2 + Math.sin(Date.now()/400 + i)*W, H); ctx.stroke();
                }
                ctx.globalCompositeOperation = 'source-over';
            };

            const drawParticles = (ctx, W, H) => {
                ctx.globalCompositeOperation = 'lighter'; engine.current.particles = engine.current.particles.filter(p => p.life > 0);
                engine.current.particles.forEach(p => {
                    p.life -= 0.05; const scale = (0.5 + p.z * 0.7) * (H/900); const sx = p.x * W; const sy = (H*0.45) + (p.z * H*0.55) + (p.y*H);
                    ctx.fillStyle = `rgba(255, 255, 255, ${p.life})`; ctx.beginPath(); ctx.arc(sx, sy, 80*p.life*scale, 0, Math.PI*2); ctx.fill();
                });
                ctx.globalCompositeOperation = 'source-over';
            };

            useEffect(() => {
                const rs = () => { if(canvasRef.current){ canvasRef.current.width = window.innerWidth; canvasRef.current.height = window.innerHeight; }};
                window.addEventListener('resize', rs); rs(); return () => cancelAnimationFrame(reqRef.current);
            }, []);

            return (
                <div className="relative w-full h-screen bg-black">
                    <canvas ref={canvasRef} />
                    
                    <div className="absolute inset-0 pointer-events-none p-6 flex flex-col justify-between">
                        <div className="flex justify-between items-start pointer-events-auto">
                            <div>
                                <h1 className="text-5xl font-black text-[#FF0055] tracking-tighter drop-shadow-lg" style={{fontFamily: 'Teko'}}>
                                    KINETIK<span className="text-white">ULTIMATE</span>
                                </h1>
                                {mode === 'AUDIO' && <div className="text-xs text-gray-500 font-mono mt-1">VOL: {Math.round(debugVol)}%</div>}
                            </div>
                            
                            {mode === 'AUDIO' && (
                                <div className="glass-panel p-3 rounded-lg flex flex-col gap-1 w-40">
                                    <label className="text-white text-xs font-bold">SENSIBILITÉ (GAIN)</label>
                                    <input type="range" min="1" max="10" step="0.5" value={gainVal} 
                                        onChange={(e) => updateGain(parseFloat(e.target.value))} />
                                    <div className="flex justify-between text-[10px] text-gray-400"><span>x1</span><span>x10</span></div>
                                </div>
                            )}
                        </div>

                        {mode === 'INIT' ? (
                            <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 pointer-events-auto flex flex-col gap-4 w-full max-w-sm px-6">
                                <button onClick={() => startSystem(true)} className="glass-panel text-white text-3xl font-bold py-6 rounded hover:bg-white/10 active:scale-95 transition-all w-full border-l-4 border-[#00F0FF]">
                                    START (MICRO)
                                </button>
                                <button onClick={() => startSystem(false)} className="text-gray-500 text-sm hover:text-white underline text-center">
                                    Si le micro ne marche pas, cliquez ici (Mode DÉMO)
                                </button>
                            </div>
                        ) : (
                            <div className="flex justify-center pointer-events-auto pb-8">
                                <button onClick={() => addDancer(false)} className="w-24 h-24 rounded-full bg-[#00F0FF] border-4 border-white shadow-[0_0_40px_#00F0FF] text-white text-5xl font-black flex items-center justify-center active:scale-90 transition-transform">
                                    +
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
